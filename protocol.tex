\documentclass{article}
\usepackage{listings}
\usepackage[utf8]{inputenc}

\title{[NAME TODO]}
\author{Paul Nykiel}

\begin{document}

\maketitle
\tableofcontents

\section{Introduction}
  Fast and extensible communication over various serial-interfaces. Primarily
  designed for radio-controlled models, mesh capable.

\section{Example Application}
  Long Range: Multiple Transmitters, Drone as Repeater. TCP for Transmitters.

\section{Protocol}
  The protocol is designed for serial interfaces, the data is binary encoded to
  optimize for slow connections.

  \subsection{Timing}
    A new package should be transmitted by the sender at a rate of 50Hz (every
    20ms) which is the rate a normal Servo or ESC gets signals at. The minimum
    time between each package should be 10ms to allow every device to parse the
    data.

  \subsection{Mesh behavior}
    Flag, Routing Timeout, UID

  \subsection{Package structure}
    The protocol is packaged based, every package
    consists of four major parts:
    \begin{itemize}
      \item Header
      \item Configuration
      \item Data
      \item Footer
    \end{itemize}

  \subsubsection{Header}
    The header consists of three bytes:
    \begin{itemize}
      \item Start byte
      \item Unique-ID
      \item Transmitter-ID
    \end{itemize}

    \paragraph{Start byte}
    The start byte is one byte which is always \emph{0xC9}.

    \paragraph{Unique-ID}
     The unique-ID is generated by the initial sender. It is used to identify a
     message, especially in a mesh-application.

    \paragraph{Algorithm for generation of the UID}
     The easiest way of generation is having a counter shared by all devices,
     every time a device receives or transmits a package the counter gets
     incremented. If the upper limit of a byte (255) is reached the counter
     overflows, this implementation guarantees maximum time between reoccurring
     UIDs.

    \paragraph{Transmitter-ID}
     A persistent ID which should be unique to the transmitter. Optimally it
     should be easily configurable by the user, for example via a configuration
     file, a settings menu or DIP-Switches on the module.

  \subsubsection{Configuration}
    The configuration consists of at least one byte.

    \paragraph{First configuration byte (general)}
     The first byte consists of the following bits:
     \begin{itemize}
       \item Bit 0-2: Resolution
       \item Bit 3-5: Channel count
       \item Bit 6: Error Bit
       \item Bit 7: Following
     \end{itemize}

    \paragraph{Resolution}
     Three bytes containing the resolution of each channel transmitted, possible
     values are:

     \begin{tabular}{|l|l|l|}
       \hline
       Value & Resolution &	Bit per Channel \\ \hline
       0b000 & 32 & 5 \\ \hline
       0b001 & 64 & 6 \\ \hline
       0b010 & 128 & 7 \\ \hline
       0b011 & 256 & 8 \\ \hline
       0b100 & 512 & 9 \\ \hline
       0b101 & 1024 & 10 \\ \hline
       0b110 & 2048 & 11\\ \hline
       0b111 & 4096 & 12 \\
       \hline
     \end{tabular}

    \paragraph{Channel count}
     Three bytes containing the amount of channels used, possible values are:

     \begin{tabular}{|l|l|l|}
       \hline
       Value & Channels \\ \hline
       0b000 & 1 \\ \hline
       0b001 & 2 \\ \hline
       0b010 & 4 \\ \hline
       0b011 & 8 \\ \hline
       0b100 & 16 \\ \hline
       0b101 & 32 \\ \hline
       0b110 & 64 \\ \hline
       0b111 & 256 \\
       \hline
     \end{tabular}

    \paragraph{Error}
     If a device registers an error (checksum, timeout during package
     transmission) this flag is set for the next 4 packages send by this device.

    \paragraph{Following}
     This byte is a flag whether the following byte is still a configuration
     byte and not a data byte.

    \paragraph{Second configuration byte (mesh)}
     The second byte consists of the following bits: Bit 0: Mesh-Message Bit
     1-4: Routing Length Bit 5-6: unused Bit 7: Following

    \paragraph{Mesh-Message}
     A flag whether the message is intended as a Mesh-Message, this flag
     defaults to false if the following flag in the first configuration byte is
     not set.

    \paragraph{Routing Length}
     A number counting the amounts of nodes this message has been passed by. The
     initial sender sets the value and every node decrements the value. If the
     value reaches zero, the package doesn't get forwarded.

    \paragraph{Following}
     This byte is a flag whether the following byte is still a configuration
     byte and not a data byte. At the moment this byte needs to be false.

  \subsubsection{Data}
    The size (in bytes) of the data section is determined by
    the resolution and the channel count:

   \emph{ceil((resolution * Channel count)/8)}

   \noindent The data is just queued together so the first r (with r being the channel
   resolution) bits are the first channel, bits r+1 to r*2 are the second
   until the last channel. If there are unused bits left at the end they are
   set to 0.

   \noindent 0 equals don't care

  \subsubsection{Footer}
    The footer consists of two bytes Checksum End byte

    \paragraph{Checksum}
     For the checksum think of the transmitted data as list starting with the
     unique-ID and ending with the last data byte. The checksum is once
     calculated by the sender and once by the recipient to verify the data is
     still correct.

    \paragraph{Algorithm}
     Now take every but the last byte and do a XOR Operation with the next byte.
     Every operation returns a new byte, so your list which was initially n
     bytes long now is only n-1 bytes long. Repeat this Process until the list
     is only one byte long, this byte is your checksum.

    \paragraph{End byte}
     The end byte is one byte which is always \emph{0x93}.

\end{document}
